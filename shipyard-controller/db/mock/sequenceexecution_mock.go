// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package db_mock

import (
	"github.com/keptn/keptn/shipyard-controller/models"
	"sync"
)

// SequenceExecutionRepoMock is a mock implementation of db.SequenceExecutionRepo.
//
// 	func TestSomethingThatUsesSequenceExecutionRepo(t *testing.T) {
//
// 		// make and configure a mocked db.SequenceExecutionRepo
// 		mockedSequenceExecutionRepo := &SequenceExecutionRepoMock{
// 			AppendTaskEventFunc: func(taskSequence models.SequenceExecution, event models.TaskEvent) (*models.SequenceExecution, error) {
// 				panic("mock out the AppendTaskEvent method")
// 			},
// 			ClearFunc: func(projectName string) error {
// 				panic("mock out the Clear method")
// 			},
// 			GetFunc: func(filter models.SequenceExecutionFilter) ([]models.SequenceExecution, error) {
// 				panic("mock out the Get method")
// 			},
// 			UpsertFunc: func(item models.SequenceExecution) error {
// 				panic("mock out the Upsert method")
// 			},
// 		}
//
// 		// use mockedSequenceExecutionRepo in code that requires db.SequenceExecutionRepo
// 		// and then make assertions.
//
// 	}
type SequenceExecutionRepoMock struct {
	// AppendTaskEventFunc mocks the AppendTaskEvent method.
	AppendTaskEventFunc func(taskSequence models.SequenceExecution, event models.TaskEvent) (*models.SequenceExecution, error)

	// ClearFunc mocks the Clear method.
	ClearFunc func(projectName string) error

	// GetFunc mocks the Get method.
	GetFunc func(filter models.SequenceExecutionFilter) ([]models.SequenceExecution, error)

	// UpsertFunc mocks the Upsert method.
	UpsertFunc func(item models.SequenceExecution) error

	// calls tracks calls to the methods.
	calls struct {
		// AppendTaskEvent holds details about calls to the AppendTaskEvent method.
		AppendTaskEvent []struct {
			// TaskSequence is the taskSequence argument value.
			TaskSequence models.SequenceExecution
			// Event is the event argument value.
			Event models.TaskEvent
		}
		// Clear holds details about calls to the Clear method.
		Clear []struct {
			// ProjectName is the projectName argument value.
			ProjectName string
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Filter is the filter argument value.
			Filter models.SequenceExecutionFilter
		}
		// Upsert holds details about calls to the Upsert method.
		Upsert []struct {
			// Item is the item argument value.
			Item models.SequenceExecution
		}
	}
	lockAppendTaskEvent sync.RWMutex
	lockClear           sync.RWMutex
	lockGet             sync.RWMutex
	lockUpsert          sync.RWMutex
}

// AppendTaskEvent calls AppendTaskEventFunc.
func (mock *SequenceExecutionRepoMock) AppendTaskEvent(taskSequence models.SequenceExecution, event models.TaskEvent) (*models.SequenceExecution, error) {
	if mock.AppendTaskEventFunc == nil {
		panic("SequenceExecutionRepoMock.AppendTaskEventFunc: method is nil but SequenceExecutionRepo.AppendTaskEvent was just called")
	}
	callInfo := struct {
		TaskSequence models.SequenceExecution
		Event        models.TaskEvent
	}{
		TaskSequence: taskSequence,
		Event:        event,
	}
	mock.lockAppendTaskEvent.Lock()
	mock.calls.AppendTaskEvent = append(mock.calls.AppendTaskEvent, callInfo)
	mock.lockAppendTaskEvent.Unlock()
	return mock.AppendTaskEventFunc(taskSequence, event)
}

// AppendTaskEventCalls gets all the calls that were made to AppendTaskEvent.
// Check the length with:
//     len(mockedSequenceExecutionRepo.AppendTaskEventCalls())
func (mock *SequenceExecutionRepoMock) AppendTaskEventCalls() []struct {
	TaskSequence models.SequenceExecution
	Event        models.TaskEvent
} {
	var calls []struct {
		TaskSequence models.SequenceExecution
		Event        models.TaskEvent
	}
	mock.lockAppendTaskEvent.RLock()
	calls = mock.calls.AppendTaskEvent
	mock.lockAppendTaskEvent.RUnlock()
	return calls
}

// Clear calls ClearFunc.
func (mock *SequenceExecutionRepoMock) Clear(projectName string) error {
	if mock.ClearFunc == nil {
		panic("SequenceExecutionRepoMock.ClearFunc: method is nil but SequenceExecutionRepo.Clear was just called")
	}
	callInfo := struct {
		ProjectName string
	}{
		ProjectName: projectName,
	}
	mock.lockClear.Lock()
	mock.calls.Clear = append(mock.calls.Clear, callInfo)
	mock.lockClear.Unlock()
	return mock.ClearFunc(projectName)
}

// ClearCalls gets all the calls that were made to Clear.
// Check the length with:
//     len(mockedSequenceExecutionRepo.ClearCalls())
func (mock *SequenceExecutionRepoMock) ClearCalls() []struct {
	ProjectName string
} {
	var calls []struct {
		ProjectName string
	}
	mock.lockClear.RLock()
	calls = mock.calls.Clear
	mock.lockClear.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *SequenceExecutionRepoMock) Get(filter models.SequenceExecutionFilter) ([]models.SequenceExecution, error) {
	if mock.GetFunc == nil {
		panic("SequenceExecutionRepoMock.GetFunc: method is nil but SequenceExecutionRepo.Get was just called")
	}
	callInfo := struct {
		Filter models.SequenceExecutionFilter
	}{
		Filter: filter,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(filter)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//     len(mockedSequenceExecutionRepo.GetCalls())
func (mock *SequenceExecutionRepoMock) GetCalls() []struct {
	Filter models.SequenceExecutionFilter
} {
	var calls []struct {
		Filter models.SequenceExecutionFilter
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// Upsert calls UpsertFunc.
func (mock *SequenceExecutionRepoMock) Upsert(item models.SequenceExecution) error {
	if mock.UpsertFunc == nil {
		panic("SequenceExecutionRepoMock.UpsertFunc: method is nil but SequenceExecutionRepo.Upsert was just called")
	}
	callInfo := struct {
		Item models.SequenceExecution
	}{
		Item: item,
	}
	mock.lockUpsert.Lock()
	mock.calls.Upsert = append(mock.calls.Upsert, callInfo)
	mock.lockUpsert.Unlock()
	return mock.UpsertFunc(item)
}

// UpsertCalls gets all the calls that were made to Upsert.
// Check the length with:
//     len(mockedSequenceExecutionRepo.UpsertCalls())
func (mock *SequenceExecutionRepoMock) UpsertCalls() []struct {
	Item models.SequenceExecution
} {
	var calls []struct {
		Item models.SequenceExecution
	}
	mock.lockUpsert.RLock()
	calls = mock.calls.Upsert
	mock.lockUpsert.RUnlock()
	return calls
}
