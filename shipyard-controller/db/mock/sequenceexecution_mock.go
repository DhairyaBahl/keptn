// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package db_mock

import (
	"github.com/keptn/keptn/shipyard-controller/models"
	"sync"
)

// SequenceExecutionRepoMock is a mock implementation of db.SequenceExecutionRepo.
//
// 	func TestSomethingThatUsesSequenceExecutionRepo(t *testing.T) {
//
// 		// make and configure a mocked db.SequenceExecutionRepo
// 		mockedSequenceExecutionRepo := &SequenceExecutionRepoMock{
// 			AppendTaskEventFunc: func(taskSequence models.SequenceExecution, event models.TaskEvent) (*models.SequenceExecution, error) {
// 				panic("mock out the AppendTaskEvent method")
// 			},
// 			ClearFunc: func(projectName string) error {
// 				panic("mock out the Clear method")
// 			},
// 			GetFunc: func(filter models.SequenceExecutionFilter) ([]models.SequenceExecution, error) {
// 				panic("mock out the Get method")
// 			},
// 			GetByTriggeredIDFunc: func(project string, triggeredID string) (*models.SequenceExecution, error) {
// 				panic("mock out the GetByTriggeredID method")
// 			},
// 			UpdateStatusFunc: func(taskSequence models.SequenceExecution) (*models.SequenceExecution, error) {
// 				panic("mock out the UpdateStatus method")
// 			},
// 			UpsertFunc: func(item models.SequenceExecution, options *models.SequenceExecutionUpsertOptions) error {
// 				panic("mock out the Upsert method")
// 			},
// 		}
//
// 		// use mockedSequenceExecutionRepo in code that requires db.SequenceExecutionRepo
// 		// and then make assertions.
//
// 	}
type SequenceExecutionRepoMock struct {
	// AppendTaskEventFunc mocks the AppendTaskEvent method.
	AppendTaskEventFunc func(taskSequence models.SequenceExecution, event models.TaskEvent) (*models.SequenceExecution, error)

	// ClearFunc mocks the Clear method.
	ClearFunc func(projectName string) error

	// GetFunc mocks the Get method.
	GetFunc func(filter models.SequenceExecutionFilter) ([]models.SequenceExecution, error)

	// GetByTriggeredIDFunc mocks the GetByTriggeredID method.
	GetByTriggeredIDFunc func(project string, triggeredID string) (*models.SequenceExecution, error)

	// UpdateStatusFunc mocks the UpdateStatus method.
	UpdateStatusFunc func(taskSequence models.SequenceExecution) (*models.SequenceExecution, error)

	// UpsertFunc mocks the Upsert method.
	UpsertFunc func(item models.SequenceExecution, options *models.SequenceExecutionUpsertOptions) error

	// calls tracks calls to the methods.
	calls struct {
		// AppendTaskEvent holds details about calls to the AppendTaskEvent method.
		AppendTaskEvent []struct {
			// TaskSequence is the taskSequence argument value.
			TaskSequence models.SequenceExecution
			// Event is the event argument value.
			Event models.TaskEvent
		}
		// Clear holds details about calls to the Clear method.
		Clear []struct {
			// ProjectName is the projectName argument value.
			ProjectName string
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Filter is the filter argument value.
			Filter models.SequenceExecutionFilter
		}
		// GetByTriggeredID holds details about calls to the GetByTriggeredID method.
		GetByTriggeredID []struct {
			// Project is the project argument value.
			Project string
			// TriggeredID is the triggeredID argument value.
			TriggeredID string
		}
		// UpdateStatus holds details about calls to the UpdateStatus method.
		UpdateStatus []struct {
			// TaskSequence is the taskSequence argument value.
			TaskSequence models.SequenceExecution
		}
		// Upsert holds details about calls to the Upsert method.
		Upsert []struct {
			// Item is the item argument value.
			Item models.SequenceExecution
			// Options is the options argument value.
			Options *models.SequenceExecutionUpsertOptions
		}
	}
	lockAppendTaskEvent  sync.RWMutex
	lockClear            sync.RWMutex
	lockGet              sync.RWMutex
	lockGetByTriggeredID sync.RWMutex
	lockUpdateStatus     sync.RWMutex
	lockUpsert           sync.RWMutex
}

// AppendTaskEvent calls AppendTaskEventFunc.
func (mock *SequenceExecutionRepoMock) AppendTaskEvent(taskSequence models.SequenceExecution, event models.TaskEvent) (*models.SequenceExecution, error) {
	if mock.AppendTaskEventFunc == nil {
		panic("SequenceExecutionRepoMock.AppendTaskEventFunc: method is nil but SequenceExecutionRepo.AppendTaskEvent was just called")
	}
	callInfo := struct {
		TaskSequence models.SequenceExecution
		Event        models.TaskEvent
	}{
		TaskSequence: taskSequence,
		Event:        event,
	}
	mock.lockAppendTaskEvent.Lock()
	mock.calls.AppendTaskEvent = append(mock.calls.AppendTaskEvent, callInfo)
	mock.lockAppendTaskEvent.Unlock()
	return mock.AppendTaskEventFunc(taskSequence, event)
}

// AppendTaskEventCalls gets all the calls that were made to AppendTaskEvent.
// Check the length with:
//     len(mockedSequenceExecutionRepo.AppendTaskEventCalls())
func (mock *SequenceExecutionRepoMock) AppendTaskEventCalls() []struct {
	TaskSequence models.SequenceExecution
	Event        models.TaskEvent
} {
	var calls []struct {
		TaskSequence models.SequenceExecution
		Event        models.TaskEvent
	}
	mock.lockAppendTaskEvent.RLock()
	calls = mock.calls.AppendTaskEvent
	mock.lockAppendTaskEvent.RUnlock()
	return calls
}

// Clear calls ClearFunc.
func (mock *SequenceExecutionRepoMock) Clear(projectName string) error {
	if mock.ClearFunc == nil {
		panic("SequenceExecutionRepoMock.ClearFunc: method is nil but SequenceExecutionRepo.Clear was just called")
	}
	callInfo := struct {
		ProjectName string
	}{
		ProjectName: projectName,
	}
	mock.lockClear.Lock()
	mock.calls.Clear = append(mock.calls.Clear, callInfo)
	mock.lockClear.Unlock()
	return mock.ClearFunc(projectName)
}

// ClearCalls gets all the calls that were made to Clear.
// Check the length with:
//     len(mockedSequenceExecutionRepo.ClearCalls())
func (mock *SequenceExecutionRepoMock) ClearCalls() []struct {
	ProjectName string
} {
	var calls []struct {
		ProjectName string
	}
	mock.lockClear.RLock()
	calls = mock.calls.Clear
	mock.lockClear.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *SequenceExecutionRepoMock) Get(filter models.SequenceExecutionFilter) ([]models.SequenceExecution, error) {
	if mock.GetFunc == nil {
		panic("SequenceExecutionRepoMock.GetFunc: method is nil but SequenceExecutionRepo.Get was just called")
	}
	callInfo := struct {
		Filter models.SequenceExecutionFilter
	}{
		Filter: filter,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(filter)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//     len(mockedSequenceExecutionRepo.GetCalls())
func (mock *SequenceExecutionRepoMock) GetCalls() []struct {
	Filter models.SequenceExecutionFilter
} {
	var calls []struct {
		Filter models.SequenceExecutionFilter
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// GetByTriggeredID calls GetByTriggeredIDFunc.
func (mock *SequenceExecutionRepoMock) GetByTriggeredID(project string, triggeredID string) (*models.SequenceExecution, error) {
	if mock.GetByTriggeredIDFunc == nil {
		panic("SequenceExecutionRepoMock.GetByTriggeredIDFunc: method is nil but SequenceExecutionRepo.GetByTriggeredID was just called")
	}
	callInfo := struct {
		Project     string
		TriggeredID string
	}{
		Project:     project,
		TriggeredID: triggeredID,
	}
	mock.lockGetByTriggeredID.Lock()
	mock.calls.GetByTriggeredID = append(mock.calls.GetByTriggeredID, callInfo)
	mock.lockGetByTriggeredID.Unlock()
	return mock.GetByTriggeredIDFunc(project, triggeredID)
}

// GetByTriggeredIDCalls gets all the calls that were made to GetByTriggeredID.
// Check the length with:
//     len(mockedSequenceExecutionRepo.GetByTriggeredIDCalls())
func (mock *SequenceExecutionRepoMock) GetByTriggeredIDCalls() []struct {
	Project     string
	TriggeredID string
} {
	var calls []struct {
		Project     string
		TriggeredID string
	}
	mock.lockGetByTriggeredID.RLock()
	calls = mock.calls.GetByTriggeredID
	mock.lockGetByTriggeredID.RUnlock()
	return calls
}

// UpdateStatus calls UpdateStatusFunc.
func (mock *SequenceExecutionRepoMock) UpdateStatus(taskSequence models.SequenceExecution) (*models.SequenceExecution, error) {
	if mock.UpdateStatusFunc == nil {
		panic("SequenceExecutionRepoMock.UpdateStatusFunc: method is nil but SequenceExecutionRepo.UpdateStatus was just called")
	}
	callInfo := struct {
		TaskSequence models.SequenceExecution
	}{
		TaskSequence: taskSequence,
	}
	mock.lockUpdateStatus.Lock()
	mock.calls.UpdateStatus = append(mock.calls.UpdateStatus, callInfo)
	mock.lockUpdateStatus.Unlock()
	return mock.UpdateStatusFunc(taskSequence)
}

// UpdateStatusCalls gets all the calls that were made to UpdateStatus.
// Check the length with:
//     len(mockedSequenceExecutionRepo.UpdateStatusCalls())
func (mock *SequenceExecutionRepoMock) UpdateStatusCalls() []struct {
	TaskSequence models.SequenceExecution
} {
	var calls []struct {
		TaskSequence models.SequenceExecution
	}
	mock.lockUpdateStatus.RLock()
	calls = mock.calls.UpdateStatus
	mock.lockUpdateStatus.RUnlock()
	return calls
}

// Upsert calls UpsertFunc.
func (mock *SequenceExecutionRepoMock) Upsert(item models.SequenceExecution, options *models.SequenceExecutionUpsertOptions) error {
	if mock.UpsertFunc == nil {
		panic("SequenceExecutionRepoMock.UpsertFunc: method is nil but SequenceExecutionRepo.Upsert was just called")
	}
	callInfo := struct {
		Item    models.SequenceExecution
		Options *models.SequenceExecutionUpsertOptions
	}{
		Item:    item,
		Options: options,
	}
	mock.lockUpsert.Lock()
	mock.calls.Upsert = append(mock.calls.Upsert, callInfo)
	mock.lockUpsert.Unlock()
	return mock.UpsertFunc(item, options)
}

// UpsertCalls gets all the calls that were made to Upsert.
// Check the length with:
//     len(mockedSequenceExecutionRepo.UpsertCalls())
func (mock *SequenceExecutionRepoMock) UpsertCalls() []struct {
	Item    models.SequenceExecution
	Options *models.SequenceExecutionUpsertOptions
} {
	var calls []struct {
		Item    models.SequenceExecution
		Options *models.SequenceExecutionUpsertOptions
	}
	mock.lockUpsert.RLock()
	calls = mock.calls.Upsert
	mock.lockUpsert.RUnlock()
	return calls
}
